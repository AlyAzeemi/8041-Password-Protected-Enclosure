;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Wed Dec 4 2019
; Processor: AT89C52
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (80C52.MCU)




org 0H
jmp Initialize

org 03H
jmp ExitButton

org 13H
setB B.3 ; Confirmation
RETI



Org 30H
Initialize:
;Global Variables

	mov 42H, #9 ;Number Of People inside ascii
	mov 43H, #5   ;Time left
	mov 41H, #4  ;Password Length
	mov 40H, #3  ;Number Of Tries
   
;Flags
	setB B.0  ;; check for password (B.0==0 if correct viceversa)
	setb B.1   ;; check if the 4 digit password is entered (B.1==0 if entered)
	clr B.2   ;; check if the room is full (B.2==1 if full)
	clr B.3   ; Light Gate Confirmation (B.3==1 If P3.3==0 which signals a person has passed through the door) 
	
;I/O Ports

	;Keypad
		mov P1, #0
		mov P2, #0ffH

	;LCD
		mov P0, #0 
		clr P3.0 
		clr P3.1
		clr P3.7

	;ExitButton P3.2
		 setB EA
		 setB Ex0
	 
	;Alarm
		clr P3.4
		
	;Light Gate 
		setB Ex1
		
	;Buzzer
		clr P3.5
		
	;Servo
		clr p3.6
		
;End Of Declarations

Main:
	ACALL Displaylcd
	CALL Input_Pass	;Stores Password starting at 30H
	CALL Check_Pass	;Compares Password and takes action accordingly
mov A, 42H
FULLR:CJNE A, #40, Main
setB B.2
CALL Displaylcd
jmp FULLR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;          PASSWORD PROCESSING          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Input_Pass: 
	mov 62H, #30H
	
	mov 45H, 41H
	
	mov 61H, #30
	IdleLoop:
	mov 60H, #200
	IPLoop:
		;mov TMOD, #00000001B
		;mov TL0, #03H
		;mov TH0, #0B4H
		;setB TR0
		;clr TF0
		CALL Keypad_Interfacing
		mov R0, 62H 
		mov @R0, A
		INC 62H
	DJNZ 45H, IPLoop
	;mov TMOD, #0
	clr B.1
RET 


Check_Pass: 
	mov R3, #0
	mov R2, 41H
	mov R0, #30H
	mov DPTR, #password
	PLoop:
		mov A, @R0
		mov 48H, A
		mov A, R3
		movc A,@A+DPTR
		CJNE A,48H, Incorrect
		INC R3
		INC R0
		mov A, R3 
	DJNZ R2,PLoop
	CALL Correct_Pass
RET
	Incorrect: CALL Wrong_Pass
RET

Wrong_Pass:
	DJNZ 40H, cont
		CALL Alarm 
	cont:
	setB B.0
RET

Correct_Pass:
	 clr B.0
	CALL OperateDoor
	jnb B.3, cont3
	Inc 42H
	clr B.3
	cont3:
	
	mov 40H, #3
RET

Alarm:
	setb P3.4 
	here3: sjmp here3
RET



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           SERVO MOTOR             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OperateDoor:
	mov 43H, #5 ;Door Open Interval(seconds)
	CALL Servo90
	DOpen:
		CALL Displaylcd
		CALL Delay1s
	DJNZ 43H, DOpen 
	CALL Servo0
RET


Servo0:
	mov 31H,#45
	Ser0:
	setb P3.6
	CALL Delay1ms
	clr P3.6
	CALL Delay17ms
	CALL Delay1ms
	CALL Delay1ms
	DJNZ 31H, Ser0
ret


Servo90:
	mov 31H,#45
	Ser90:
	setb P3.6
	CALL Delay1500us
	clr P3.6
	CALL Delay17ms
	CALL Delay1500us
	DJNZ 31H, Ser90
ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;             ISRs              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ExitButton:
	CALL OperateDoor
	jnb B.3, cont2
	DEC 42H
	clr B.3
	cont2:
RETI

Flush:
	;TimerControl
	clr TR0
	;DJNZ 60H, IPL
	;DJNZ 61H, IL
	;mov SP, #02FH ;Reset SP
	;mov R6, 41H	; Reload input Loop control
	;mov 61H, #30 ;Reload IdleTimer Loop control
	
	;flush
	mov 30H, #0
	mov 31H, #0
	mov 32H, #0
	mov 33H, #0
	;setB TR0
RETI


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;          KEYPAD INTERFACING          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Keypad_Interfacing:
	rows equ  4    ; keypad info
	cols equ  3

	mov a,#0h    ; creating mask for checking columns  
	mov r1,#0h

	rot_again: 
		setb c
		inc r1
		rlc	a
		cjne r1,#cols,rot_again
	
	start:      ; start scanning
		mov r0,a    ; mask is in r0

	again:
		mov r1,#0feh ; ground 0th row
		mov r2,#0
		mov r3,#0

	next_row:
		mov p1,r1 
		mov a,p2

		anl a,r0

		cjne a,0h,key_pressed
		mov a,r1
		rl a
		mov r1,a
		inc r2 				  ; r2 will contain the row index
		cjne r2,#rows,next_row
	jmp again

	key_pressed:
		CALL Delay25ms	  ; debounce time
	again1:
		rrc a
		jnc findkey
		inc r3				; r3 contains the column index
	jmp again1

	findkey:
		mov a,#cols
		mov b,r2
		mul ab
		add a,r3
		mov dptr,#key
		movc a,@a+dptr
		mov r4,a
             
	
	release_key:
		mov a,p2
		anl a,r0
		cjne a,0h,release_key
		CALL Delay25ms	  ; debounce time
		mov A,r4
	
	
	
	
	;;buzzer
		setB P3.5 
	
		mov R7, #10
		Buzz:
		   CALL Delay17ms
		   CALL Delay1500us
		   CALL Delay1500us
		DJNZ R7, Buzz
		
		clr P3.5
	
RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;          DELAYS          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;Debounce Delay
Delay25ms:
	MOV R5,#45
		L1:MOV R6,#255
			L2:DJNZ R6, L2
	DJNZ R5, L1
RET


Delay1500us:
	mov R5, #3
	L5:
		mov R6, #229
		mov R6, #229
		L6: DJNZ R6, L6 
	DJNZ R5, L5  
RET

Delay17ms:
	mov R5, #17
	L7:
		CALL Delay1ms
	DJNZ R5, L7
RET

Delay1ms:
	mov 44H, #3
	L3:
		mov R6, #157
		L4: DJNZ R6, L4 
	DJNZ 44H, L3  
RET

Delay1s:
	mov R7,#40
	L8:
	 call Delay25ms
	djnz R7 ,L8
ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           Display             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
doreturn:
RET

Displaylcd:

       
	jb B.2, full
	jmp next0

	full:
		MOV DPTR,#MYCOM0

		C0:
			CLR A
			MOVC A,@A+DPTR
			ACALL COMNWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ SEND_DAT0
		SJMP C0


	SEND_DAT0:
		MOV DPTR,#MYDATA0

		D0:
			CLR A
			MOVC A,@A+DPTR
			ACALL DATAWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ $        ;;stay here till hard reset
		SJMP D0

		next0:
			MOV DPTR,#MYCOM1

			C1: 
				CLR A
				MOVC A,@A+DPTR
				ACALL COMNWRT ;CALL command subroutine
				ACALL DELAY ;give LCD some time
				INC DPTR
		JZ SEND_DAT1

	SJMP C1


	SEND_DAT1:
		MOV DPTR,#MYDATA1

		D1: CLR A
			MOVC A,@A+DPTR
			ACALL DATAWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ next1
		SJMP D1
		
		next1:
			jb B.1 ,doreturn
			
			JB B.0 , wrong
		jmp Damn_right

		wrong:
			MOV DPTR,#MYCOM21
			C21: 
				CLR A
				MOVC A,@A+DPTR
				ACALL COMNWRT ;CALL command subroutine
				ACALL DELAY ;give LCD some time
				INC DPTR
		JZ SEND_DAT21

	SJMP C21


	SEND_DAT21:
		MOV DPTR,#MYDATA21

		D21: CLR A
			MOVC A,@A+DPTR
			ACALL DATAWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ next21
		SJMP D21

		next21:
			MOV DPTR,#MYCOM3
		jmp next3

		Damn_right:
			MOV DPTR,#MYCOM22
			C22: CLR A
			MOVC A,@A+DPTR
			ACALL COMNWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
		JZ SEND_DAT22

	SJMP C22


	SEND_DAT22:
		MOV DPTR,#MYDATA22

		D22:
			CLR A
			MOVC A,@A+DPTR
			ACALL DATAWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ next22
		SJMP D22

		next22:
			MOV DPTR,#MYCOM3
			next2:
				C3:
					CLR A
					MOVC A,@A+DPTR
					ACALL COMNWRT ;CALL command subroutine
					ACALL DELAY ;give LCD some time
					INC DPTR
			JZ SEND_DAT3

	SJMP C3


	SEND_DAT3:
		MOV DPTR,#MYDATA3

		D3: CLR A
			MOVC A,@A+DPTR
			ACALL DATAWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ time
		SJMP D3
		
		time:
			mov A, 43H
			add A, #30h
			CALL DATAWRT
			ACALL DELAY
			
		next3:
			MOV DPTR,#MYCOM4
			C4:
				CLR A
				MOVC A,@A+DPTR
				ACALL COMNWRT ;CALL command subroutine
				ACALL DELAY ;give LCD some time
				INC DPTR
		JZ SEND_DAT4

	SJMP C4


	SEND_DAT4:
		MOV DPTR,#MYDATA4

		D4: CLR A
			MOVC A,@A+DPTR
			ACALL DATAWRT ;CALL command subroutine
			ACALL DELAY ;give LCD some time
			INC DPTR
			JZ number
		SJMP D4
		
		number:
			mov A, 42H
			add A, #30H
			CALL DATAWRT
			ACALL DELAY
RET

COMNWRT: ;send command to LCD
	MOV P0,A ;copy reg A to P0
	CLR P3.0 ;RS=0 for command
	CLR P3.1 ;R/W=0 for write
	SETB P3.7 ;E=1 for high pulse
	ACALL DELAY ;give LCD some time
	CLR P3.7 ;E=0 for H-to-L pulse
RET


DATAWRT: ;write data to LCD
	MOV P0,A ;copy reg A to port 0
	SETB P3.0 ;RS=1 for data
	CLR P3.1 ;R/W=0 for write
	SETB P3.7 ;E=1 for high pulse
	ACALL DELAY ;give LCD some time
	CLR P3.7 ;E=0 for H-to-L pulse
RET

DELAY:
	MOV R3,#01 ;50 or higher for fast CPUs
	HERE2: MOV R4,#255 ;R4 = 255
	HERE: DJNZ R4,HERE ;stay until R4 becomes 0
	DJNZ R3,HERE2
RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           ARRAYS            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

jmp terminate
ORG 0F00H
MYCOM0: DB 38H,0CH,80H,0 ; commands and null
MYDATA0: DB "R O O M         F U L L         ",0
MYCOM1: DB 38H,0CH,80H,0 ; commands and null
MYDATA1: DB "Enter Password:",0
MYCOM21: DB 38H,0CH,0C0H,0 ; commands and null
MYDATA21: DB "Access Denied",0
MYCOM22: DB 38H,0CH,0C0H,0 ; commands and null
MYDATA22: DB "Access Granted",0
MYCOM3: DB 38H,0CH,90H,0 ; commands and null
MYDATA3: DB "Time Left:",0
MYCOM4: DB 38H,0CH,0D0H,0 ; commands and null
MYDATA4: DB "People Inside:",0

key: DB 1,2,3,4,5,6,7,8,9,'*',0,'#'
password: DB 4,2,0,'#'

terminate:
end